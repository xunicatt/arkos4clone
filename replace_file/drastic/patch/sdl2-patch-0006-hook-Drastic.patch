From 4f63e4140c4005778379e83c57f8ab1d9aa259f4 Mon Sep 17 00:00:00 2001
From: lcdyk0517 <lcdyk0517@qq.com>
Date: Wed, 3 Dec 2025 12:27:58 +0000
Subject: [PATCH] SDL2: hook Drastic

---
 CMakeLists.txt          |    2 +-
 src/render/SDL_render.c | 2157 +++++++++++++++++++++++++++++++++++++++
 src/video/SDL_video.c   |  233 +++++
 3 files changed, 2391 insertions(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e45b53e20..f7ee0b435 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -721,7 +721,7 @@ if(USE_GCC OR USE_CLANG OR USE_INTELCC OR USE_QCC)
     check_c_compiler_flag("" HAVE_NO_UNDEFINED)
     set(CMAKE_REQUIRED_FLAGS ${ORIG_CMAKE_REQUIRED_FLAGS})
     if(HAVE_NO_UNDEFINED AND NOT (USE_CLANG AND WINDOWS))
-      list(APPEND EXTRA_LDFLAGS_BUILD "-Wl,--no-undefined")
+      list(APPEND EXTRA_LDFLAGS_BUILD "-Wl,--no-undefined -lfreeimage -lSDL2_ttf -lSDL2_image")
     endif()
   endif()
 
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index cc3d16959..28b231cc4 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -29,10 +29,19 @@
 #include "software/SDL_render_sw_c.h"
 #include "../video/SDL_pixels_c.h"
 
+#include <limits.h>
+#include <stdbool.h>
+#include <FreeImage.h>
+#include <unistd.h>
+#include <libgen.h>
+
 #if defined(__ANDROID__)
 #include "../core/android/SDL_android.h"
 #endif
 
+#include <sys/mman.h>
+#include "SDL_ttf.h"
+#include "SDL_image.h"
 /* as a courtesy to iOS apps, we don't try to draw when in the background, as
 that will crash the app. However, these apps _should_ have used
 SDL_AddEventWatch to catch SDL_APP_WILLENTERBACKGROUND events and stopped
@@ -137,9 +146,1052 @@ static const SDL_RenderDriver *render_drivers[] = {
 };
 #endif /* !SDL_RENDER_DISABLED */
 
+#define NDS_VER                     "v2.01"
+#define NDS_W                       256
+#define NDS_H                       192
+#define NDS_Wx2                     (NDS_W * 2)
+#define NDS_Hx2                     (NDS_H * 2)
+#define NDS_Wx3                     (NDS_W * 3)
+#define NDS_Hx3                     (NDS_H * 3)
+#define NDS_Wx4                     (NDS_W * 4)
+#define NDS_Hx4                     (NDS_H * 4)
+
+#define NDS_DRASTIC_H 256
+#define NDS_DRASTIC_V 192
+
+#define MENU_CURSOR_FILE            "resources/menu/640/2/cursor.png"
+#define DRASTIC_MENU_YES_FILE       "resources/menu/640/2/drastic_yes.png"
+#define DRASTIC_MENU_NO_FILE        "resources/menu/640/2/drastic_no.png"
+#define DRASTIC_MENU_CURSOR_FILE    "resources/menu/640/2/drastic_cursor.png"
+#define DRASTIC_MENU_BG0_FILE       "resources/menu/640/2/drastic_bg0.png"
+#define DRASTIC_MENU_BG1_FILE       "resources/menu/640/2/drastic_bg1.png"
+
+#define NDS_DRASTIC_SCR_MAX 2
+
+#define likely(x)       __builtin_expect(!!(x), 1)
+#define unlikely(x)     __builtin_expect(!!(x), 0)
+
+enum nds_drastic_disp_mode {
+	DISP_MODE_H,		/* horizon display mode. */
+	DISP_MODE_V,		/* vertical display mode. */
+	DISP_MODE_H_SINGLE,	/* single horizon display mode. */
+	DISP_MODE_MENU,		/* menu display mode. */
+	DISP_MODE_MAX,
+};
+
+enum nds_target_disp_mode {
+	DISP_TGT_MODE_TOP_FULL, 		/* top screen full. 上屏占满*/
+	DISP_TGT_MODE_V_ORI,			/* vertical orignal, specially for DQ series. 上下一样大 */
+	DISP_TGT_MODE_2DS,				/* 2ds style, middle pixel res. */
+    DISP_TGT_MODE_TRANSPARENT,		/* Secondary Transparent Display. */
+	DISP_TGT_MODE_TOP_CONN_BOTTOM,	/* two screens connected together. 第二种竖屏 */
+	DISP_TGT_MODE_H_SINGLE,			/* single horizon display mode. 显示单个屏幕 */
+	DISP_TGT_MODE_MENU,				/* menu display mode. 菜单模式 */
+	DISP_TGT_MODE_MAX,
+};
+
+enum nds_target_disp_res {
+	DISP_RES_720_720,	/* 720x720. Used by RGB30/20SX. */
+	DISP_RES_640_480,	/* 640x480. */
+	DISP_RES_720P,		/* 1280x720. */
+	DISP_RES_1080P,		/* 1920x1080. */
+	/* Not intrested for now. */
+//	DISP_RES_2K,		/* 2560x1440. */
+//	DISP_RES_4K,		/* 3840x2160. */
+	DISP_RES_MAX,
+};
+
+#define ALIGN_ADDR(addr)    ((void*)((size_t)(addr) & ~(sysconf(_SC_PAGESIZE) - 1)))
+#define PREFIX "nds"
+
+#define NDS_DRASTIC_MENU_MAIN           1
+#define NDS_DRASTIC_MENU_OPTION         2
+#define NDS_DRASTIC_MENU_CONTROLLER     3
+#define NDS_DRASTIC_MENU_CONTROLLER2    4
+#define NDS_DRASTIC_MENU_FIRMWARE       5
+#define NDS_DRASTIC_MENU_CHEAT          6
+#define NDS_DRASTIC_MENU_ROM            7
+
+#ifndef MAX_PATH
+    #define MAX_PATH                128
+#endif
+
+#define MAX_MENU_LINE               128
+
+typedef struct _CUST_MENU_SUB {
+    int x;
+    int y;
+    int cheat;
+    int enable;
+    uint32_t fg;
+    uint32_t bg;
+    char msg[MAX_PATH];
+} CUST_MENU_SUB;
+
+typedef struct _CUST_MENU {
+    int cnt;
+    CUST_MENU_SUB item[MAX_MENU_LINE];
+} CUST_MENU;
+
+static CUST_MENU drastic_menu = {0};
+
+#define DEF_LANG_SLOT               0
+#define DEF_LANG_LANG               "english"
+#define LANG_FILE_LEN               16
+#define MAX_LANG_FILE               32
+#define MAX_LANG_LINE               128
+#define MAX_MENU_LINE               128
+
+    #define DEF_FB_W                640
+    #define DEF_FB_H                480
+    #define FB_BPP                  4
+    #define IMG_W                   640
+    #define IMG_H                   480
+    #define SCREEN_DMA_SIZE         (NDS_Wx2 * NDS_Hx2 * 4)
+    #define RELOAD_BG_COUNT         120
+    #define INIT_CPU_CORE           2
+    #define DEINIT_CPU_CORE         2
+    #define DEF_FONT_SIZE           24
+    #define BAT_MAX_VAL             4080000
+    #define BAT_MIN_VAL             3400000
+
+static char *translate[MAX_LANG_LINE] = {0};
+
+int FB_W = 0;
+int FB_H = 0;
+int FB_SIZE = 0;
+int LINE_H = 0;
+int TMP_SIZE = 0;
+int FONT_SIZE = 0;
+
+typedef struct _NDS {
+	TTF_Font *font;
+	struct _LANG {
+	        char trans[MAX_LANG_FILE][LANG_FILE_LEN];
+		char path[MAX_PATH];
+	} lang;
+    struct _MENU {
+	SDL_Surface *cursor;
+        struct _DRASTIC {
+            int enable;
+            SDL_Surface *bg0;
+            SDL_Surface *bg1;
+            SDL_Surface *main;
+            SDL_Surface *yes;
+            SDL_Surface *no;
+            SDL_Surface *cursor;
+	    SDL_Texture *mtext;
+        } drastic;
+        uint32_t c0;
+        uint32_t c1;
+        uint32_t c2;
+        char path[MAX_PATH];
+    } menu;
+} NDS;
+
+NDS nds = {0};
+static SDL_Surface *cvt = NULL;
+
+const char *nds_bezels = NULL;
+
+static char *nds_bg_png[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_TOP_FULL] = "bg_vertical_full.png",
+	[DISP_TGT_MODE_2DS] = "bg_vertical_2ds.png",
+    [DISP_TGT_MODE_TRANSPARENT] = "bg_horizon_single.png",
+	[DISP_TGT_MODE_V_ORI] = "bg_vertical.png",
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = "bg_vertical_ext.png",
+	[DISP_TGT_MODE_H_SINGLE] = "bg_horizon_single.png",
+	[DISP_TGT_MODE_MENU] = "bg_menu.png",
+};
+
+static SDL_bool nds_is_overlapping_layout = SDL_FALSE;
+
+struct nds_disp_resize {
+	SDL_Texture *bg_tex;
+	float pointer_scale[NDS_DRASTIC_SCR_MAX];
+	union {
+		SDL_Rect tgt_rect[NDS_DRASTIC_SCR_MAX];
+		struct {
+			SDL_Rect menu_src_rect;
+			SDL_Rect menu_dst_rect;
+		};
+	};
+};
+
+static struct nds_disp_resize disp_720x720[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 上屏2倍，下屏1.5倍
+			{104, 0, 512, 384},
+			{168, 432, 384, 288},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 上下都是1.875倍
+			{120, 0, 480, 360},
+			{120, 360, 480, 360},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 上屏2.75倍最大，下屏1倍
+			{8, 0, 704, 528},
+			{232, 528, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+             // 上屏2.5倍，下屏1倍
+			{40, 0, 640, 480},
+			{232, 528, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏2.8倍最大
+			{8, 96, 704, 528},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏2.8倍最大，画中画1倍
+			{8, 96, 704, 528},
+			{456, 96, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+            // 菜单
+			{0, 0, 800, 480},
+			{0, 0, 720, 720},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_1024x768[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 上屏2倍，下屏1.5倍
+			{256, 0, 512, 384},
+			{320, 480, 384, 288},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 上下都是2倍
+			{256, 0, 512, 384},
+			{256, 384, 512, 384},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 上屏3.5倍，下屏0.5倍
+			{64, 0, 896, 672},
+			{448, 672, 128, 96},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 上屏3倍，下屏1倍
+			{128, 0, 768, 576},
+			{384, 576, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏4倍最大
+			{0, 0, 1024, 768},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏4倍最大，画中画1倍
+			{0, 0, 1024, 768},
+			{768, 0, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+            // 菜单
+			{0, 0, 800, 480},
+			{0, 0, 1024, 768},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_1280x720[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 左屏3倍，右屏1.5倍
+			{0, 72, 768, 576},
+			{896, 216, 384, 288},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 左右都是2.5倍
+			{0, 120, 640, 480},
+			{640, 120, 640, 480},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 左屏3.5倍，右屏1.5倍
+			{0, 24, 896, 672},
+			{896, 216, 384, 288},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 左屏3倍最大，右屏2倍
+			{0, 72, 768, 576},
+			{768, 168, 512, 384},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏3.5倍最大
+			{192, 24, 896, 672},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏3.7倍最大，画中画1倍
+			{192, 24, 896, 672},
+			{832, 24, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 1280, 720},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_1920x1080[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 左屏4倍，右屏3倍
+			{0, 156, 1024, 768},
+			{1152, 252, 768, 576},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 左右都是3.75倍
+			{0, 180, 960, 720},
+			{960, 180, 960, 720},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 左屏5.5倍最大，右屏2倍
+			{0, 12, 1408, 1056},
+			{1408, 348, 512, 384},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 左屏5倍，右屏2倍
+			{0, 60, 1280, 960},
+			{1408, 348, 512, 384},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏5.5倍最大
+			{256, 12, 1408, 1056},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏5.5倍最大，画中画2倍
+			{256, 12, 1408, 1056},
+			{1152, 12, 512, 384},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 1920, 1080},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_640x480[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 上下都是1倍
+			{192, 0, 256, 192},
+			{192, 288, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 上下都是1.25倍
+			{160, 0, 320, 240},
+			{160, 240, 320, 240},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 上屏2倍，下屏0.5倍
+			{64, 0, 512, 384},
+			{256, 384, 128, 96},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 上屏1.5倍，下屏1倍
+			{128, 0, 384, 288},
+			{192, 288, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大
+			{0, 0, 640, 480},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大，画中画1倍
+			{0, 0, 640, 480}, 
+			{384, 0, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 640, 480},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_854x480[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 左屏2倍，右屏1倍
+			{0, 48, 512, 384},
+			{588, 144, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 左右都是1.65625倍
+			{3, 81, 424, 318},
+			{427, 81, 424, 318},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 左屏2.5倍最大，右屏0.8125倍
+			{3, 0, 640, 480},
+			{643, 162, 208, 156},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 左屏2.25倍，右屏1倍
+			{0, 24, 576, 432},
+			{598, 144, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大
+			{107, 0, 640, 480},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大，画中画1倍
+			{107, 0, 640, 480},
+			{491, 0, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 800, 480},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_800x480[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 左屏2倍，右屏1倍
+			{0, 48, 512, 384},
+			{544, 144, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 左右都是1.5625倍
+			{0, 90, 400, 300},
+			{400, 90, 400, 300},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 左屏2.5倍最大，右屏0.625倍
+			{0, 0, 640, 480},
+			{640, 180, 160, 120},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 左屏2倍，右屏1.125倍
+			{0, 48, 512, 384},
+			{512, 132, 288, 216},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大
+			{80, 0, 640, 480},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大，画中画1倍
+			{80, 0, 640, 480},
+			{464, 0, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 800, 480},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_720x480[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 左屏2倍，右屏0.8125倍
+			{0, 48, 512, 384},
+			{544, 162, 208, 156},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 左右都为1.40625倍
+			{0, 105, 360, 270},
+			{360, 105, 360, 270},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 左屏2.5倍 右屏0.3125倍
+			{0, 0, 640, 480},
+			{640, 210, 80, 60},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+        .tgt_rect = {
+            // 左屏1.8125倍，右屏1倍
+			{0, 66, 464, 348},
+			{464, 144, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大
+			{40, 0, 640, 480},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏2.5倍最大，画中画1倍
+			{40, 0, 640, 480},
+			{424, 0, 256, 192},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 800, 480},
+		},
+	},
+};
+
+static struct nds_disp_resize disp_480x320[DISP_TGT_MODE_MAX] = {
+	[DISP_TGT_MODE_2DS] = {
+		.tgt_rect = {
+            // 左屏1倍，右屏0.5倍
+			{0, 64, 256, 192},
+			{352, 112, 128, 96},
+		},
+	},
+	[DISP_TGT_MODE_V_ORI] = {
+		.tgt_rect = {
+            // 左右都是0.9375倍
+			{0, 70, 240, 180},
+			{240, 70, 240, 180},
+		},
+	},
+	[DISP_TGT_MODE_TOP_FULL] = {
+		.tgt_rect = {
+            // 左屏1.5倍最大，右屏0.375倍
+			{0, 16, 384, 288},
+			{384, 124, 96, 72},
+		},
+	},
+	[DISP_TGT_MODE_TOP_CONN_BOTTOM] = {
+		.tgt_rect = {
+            // 左屏1.375倍，右屏0.5倍
+			{0, 28, 352, 264},
+			{352, 112, 128, 96},
+		},
+	},
+	[DISP_TGT_MODE_H_SINGLE] = {
+		.tgt_rect = {
+            // 单屏1.5倍最大
+			{48, 16, 384, 288},
+			{0, 0, 0, 0},
+		},
+	},
+    [DISP_TGT_MODE_TRANSPARENT] = {
+		.tgt_rect = {
+            // 单屏1.5倍最大+画中画0.5倍
+			{48, 16, 384, 288},
+			{304, 16, 128, 96},
+		},
+	},
+	[DISP_TGT_MODE_MENU] = {
+		.tgt_rect = {
+			{0, 0, 800, 480},
+			{0, 0, 480, 320},
+		},
+	},
+};
+
+static struct nds_disp_resize nds_disp_resize_used[DISP_MODE_MAX];
+struct nds_disp_resize *res_sel = NULL;
+
+static uint16_t disp_mode = DISP_MODE_MAX;
+static SDL_Rect disp_rect;
+
 static char renderer_magic;
 static char texture_magic;
 
+SDL_Texture* loadBackground(char *image, SDL_Renderer *mRenderer)
+{
+	SDL_Texture *mBackground;
+	unsigned char* buffer;
+	int w, h, scan_width;
+	FREE_IMAGE_FORMAT format;
+	FIBITMAP* imagen;
+
+	if (access(image, F_OK) < 0)
+		return NULL;
+
+	format = FreeImage_GetFileType(image, 0);
+	imagen = FreeImage_Load(format, image, 0);
+
+	w = FreeImage_GetWidth(imagen);
+	h = FreeImage_GetHeight(imagen);
+	scan_width = FreeImage_GetPitch(imagen);
+
+	buffer = malloc(w * h * 4);
+	FreeImage_ConvertToRawBits(buffer, imagen, scan_width, 32, 0, 0, 0, 1);
+	FreeImage_Unload(imagen);
+
+	mBackground = SDL_CreateTexture(mRenderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, w, h);
+	SDL_SetTextureBlendMode(mBackground, SDL_BLENDMODE_BLEND);
+	SDL_UpdateTexture(mBackground, NULL, buffer, w * sizeof(char) * 4);
+	free(buffer);
+
+	return mBackground;
+}
+
+static void nds_drastic_deinit()
+{
+	int i;
+
+	for (i = 0; i < DISP_TGT_MODE_MAX - 1; i++) {
+		if (res_sel[i].bg_tex)
+			SDL_DestroyTexture(res_sel[i].bg_tex);
+		res_sel[i].bg_tex = NULL;
+	}
+}
+static void strip_newline(char *p)
+{
+    int cc = 0, len = strlen(p);
+
+    for(cc=0; cc<len; cc++) {
+        if ((p[cc] == '\r') || (p[cc] == '\n')) {
+            p[cc] = 0;
+            break;
+        }
+    }
+}
+static int lang_load(const char *lang)
+{
+    FILE *f = NULL;
+    char buf[MAX_PATH << 1] = {0};
+
+    if (strcasecmp(nds.lang.trans[DEF_LANG_SLOT], DEF_LANG_LANG)) {
+        sprintf(buf, "%s", lang);
+        f = fopen(buf, "r");
+
+        if (f != NULL) {
+            int cc = 0, len = 0;
+
+            memset(buf, 0, sizeof(buf));
+            while (fgets(buf, sizeof(buf), f)) {
+                strip_newline(buf);
+                len = strlen(buf) + 2;
+                if (len == 0) {
+                    continue;
+                }
+
+                if (translate[cc] != NULL) {
+                    free(translate[cc]);
+                }
+                translate[cc] = malloc(len);
+                if (translate[cc] != NULL) {
+                    memcpy(translate[cc], buf, len);
+                    //printf(PREFIX"Translate: \'%s\'(len=%d)\n", translate[cc], len);
+                }
+                cc+= 1;
+                if (cc >= MAX_LANG_LINE) {
+                    break;
+                }
+                memset(buf, 0, sizeof(buf));
+            }
+            fclose(f);
+        }
+        else {
+            printf(PREFIX"Failed to open lang folder \'%s\'\n", nds.lang.path);
+        }
+    }
+    return 0;
+}
+
+int reload_menu(char *folder)
+{
+    SDL_Surface *t = NULL;
+    char buf[MAX_PATH << 1] = {0};
+
+    cvt = SDL_CreateRGBSurface(SDL_SWSURFACE, FB_W, FB_H, 32, 0, 0, 0, 0);
+
+    sprintf(buf, "%s/%s", folder, MENU_CURSOR_FILE);
+    nds.menu.cursor = IMG_Load(buf);
+
+    sprintf(buf, "%s/%s", folder, DRASTIC_MENU_CURSOR_FILE);
+    nds.menu.drastic.cursor = IMG_Load(buf);
+
+    sprintf(buf, "%s/%s", folder, DRASTIC_MENU_YES_FILE);
+    t = IMG_Load(buf);
+    if (t) {
+        SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
+        if (nds.menu.drastic.yes) {
+            SDL_FreeSurface(nds.menu.drastic.yes);
+        }
+        nds.menu.drastic.yes = SDL_CreateRGBSurface(SDL_SWSURFACE, nrt.w, nrt.h, 32, t->format->Rmask, t->format->Gmask, t->format->Bmask, t->format->Amask);
+        if (nds.menu.drastic.yes) {
+            SDL_SoftStretch(t, NULL, nds.menu.drastic.yes, NULL);
+        }
+        SDL_FreeSurface(t);
+    }
+
+    sprintf(buf, "%s/%s", folder, DRASTIC_MENU_BG0_FILE);
+    t = IMG_Load(buf);
+    if (t) {
+        if (nds.menu.drastic.bg0) {
+            SDL_FreeSurface(nds.menu.drastic.bg0);
+        }
+        nds.menu.drastic.bg0 = SDL_ConvertSurface(t, cvt->format, 0);
+        SDL_FreeSurface(t);
+    } else {
+	printf("Load bg0 failed\n");
+    }
+
+    sprintf(buf, "%s/%s", folder, DRASTIC_MENU_BG1_FILE);
+    t = IMG_Load(buf);
+    if (t) {
+        if (nds.menu.drastic.bg1) {
+            SDL_FreeSurface(nds.menu.drastic.bg1);
+        }
+        nds.menu.drastic.bg1 = SDL_ConvertSurface(t, cvt->format, 0);
+        SDL_FreeSurface(t);
+    } else {
+	printf("Load bg1 failed\n");
+    }
+
+    sprintf(buf, "%s/%s", folder, DRASTIC_MENU_NO_FILE);
+    t = IMG_Load(buf);
+    if (t) {
+        SDL_Rect nrt = {0, 0, LINE_H - 2, LINE_H - 2};
+        if (nds.menu.drastic.no) {
+            SDL_FreeSurface(nds.menu.drastic.no);
+        }
+        nds.menu.drastic.no = SDL_CreateRGBSurface(SDL_SWSURFACE, nrt.w, nrt.h, 32, t->format->Rmask, t->format->Gmask, t->format->Bmask, t->format->Amask);
+        if (nds.menu.drastic.no) {
+            SDL_SoftStretch(t, NULL, nds.menu.drastic.no, NULL);
+        }
+        SDL_FreeSurface(t);
+    }
+
+    return 0;
+}
+
+static char* get_linux_executable_path(char *buffer, size_t buf_size) {
+    // 通过读取 /proc/self/exe 获取当前进程的完整路径
+    ssize_t len = readlink("/proc/self/exe", buffer, buf_size - 1);
+    
+    if (len == -1) {
+        perror("readlink failed");
+        return NULL;
+    }
+    
+    buffer[len] = '\0';  // 确保字符串终止
+    
+    // 提取目录部分（不修改原始缓冲区）
+    char *dir_buffer = malloc(buf_size);
+    if (!dir_buffer) {
+        perror("malloc failed");
+        return NULL;
+    }
+    
+    strncpy(dir_buffer, buffer, len);
+    dir_buffer[len] = '\0';
+    
+    char *dir = dirname(dir_buffer);  // 安全提取目录
+    strncpy(buffer, dir, buf_size);
+    
+    free(dir_buffer);
+    return buffer;
+}
+
+static char* get_system_language() {
+    // 按优先级检查环境变量
+    const char *vars[] = {"LC_ALL", "LC_MESSAGES", "LANG", NULL};
+    char *lang = NULL;
+
+    for (int i = 0; vars[i]; ++i) {
+        lang = getenv(vars[i]);
+        if (lang && *lang) break; // 找到有效值
+    }
+
+    if (!lang) return strdup("C"); // 默认 POSIX  locale
+
+    // 提取语言代码（如 "en" 或 "zh"）
+    char *result = strdup(lang);
+    char *underscore = strchr(result, '.');
+    if (underscore) *underscore = '\0'; // 截断到第一个下划线
+
+    return result;
+}
+
+static void nds_drastic_init(SDL_Renderer *mRenderer, SDL_Window *window)
+{
+	int displayIndex;
+	int ret;
+	SDL_Rect rect;
+	char texpath[PATH_MAX];
+	int i;
+    	char buf[MAX_PATH << 1] = {0};
+    	char folder[MAX_PATH] = {0};
+	char *lang = get_system_language();
+
+    LINE_H = 30;
+    FONT_SIZE = DEF_FONT_SIZE;
+
+    FB_W = DEF_FB_W;
+    FB_H = DEF_FB_H;
+    FB_SIZE = FB_W * FB_H * FB_BPP * 2;
+    TMP_SIZE = FB_W * FB_H * FB_BPP;
+    nds.menu.c0 = 0xffffff;
+    nds.menu.c1 = 0x000000;
+    nds.menu.c2 = 0x289a35;
+
+	nds.menu.drastic.main = SDL_CreateRGBSurface(SDL_SWSURFACE, FB_W, FB_H, 32, 0, 0, 0, 0);
+	if (!nds.menu.drastic.main) {
+		printf("create main menu surface failed\n");
+		return;
+	}
+	nds.menu.drastic.mtext = SDL_CreateTextureFromSurface(mRenderer, nds.menu.drastic.main);
+	if (!nds.menu.drastic.mtext) {
+		printf("Create main test failed\n");
+	}
+
+	if (!get_linux_executable_path(folder, sizeof(folder))) {
+		printf("Get folder failed\n");
+		exit(1);
+	}
+
+	sprintf(buf, "%s/%s", folder, "resources/font/font.ttf");
+	TTF_Init();
+	nds.font = TTF_OpenFont(buf, FONT_SIZE);
+	if (!nds.font) {
+		printf("Open font failed\n");
+	}
+
+	reload_menu(folder);
+	if (strstr(lang, "zh_CN"))
+		sprintf(buf, "%s/%s", folder, "resources/lang/chinese_cn");
+	else if (strstr(lang, "zh_TW"))
+		sprintf(buf, "%s/%s", folder, "resources/lang/chinese_tw");
+	else if (strstr(lang, "de"))
+		sprintf(buf, "%s/%s", folder, "resources/lang/german_deu");
+	else if (strstr(lang, "es"))
+		sprintf(buf, "%s/%s", folder, "resources/lang/spanish_sp");
+	else
+		memset(buf, 0, sizeof(buf));
+	lang_load(buf);
+
+	displayIndex = SDL_GetWindowDisplayIndex(window);
+	if (displayIndex < 0) {
+		printf("SDL_GetWindowDisplayIndex failed.\n");
+		return;
+	}
+
+	ret = SDL_GetDisplayUsableBounds(displayIndex, &rect);
+	if (ret < 0) {
+		printf("SDL_GetDisplayUsableBounds failed.\n");
+	}
+
+    if (rect.w == 720 && rect.h == 720) {
+        res_sel = disp_720x720;
+        nds_bezels = "resources/bg/720x720/";
+    } else if (rect.w == 1280 && rect.h == 720) {
+        res_sel = disp_1280x720;
+        nds_bezels = "resources/bg/1280x720/";
+    } else if (rect.w == 1920 && rect.h == 1080) {
+        res_sel = disp_1920x1080;
+        nds_bezels = "resources/bg/1920x1080/";
+    } else if (rect.w == 1024 && rect.h == 768) {
+        res_sel = disp_1024x768;
+        nds_bezels = "resources/bg/1024x768/";
+    } else if (rect.w == 640 && rect.h == 480) {
+        res_sel = disp_640x480;
+        nds_bezels = "resources/bg/640x480/";
+    } else if (rect.w == 800 && rect.h == 480) {
+        res_sel = disp_800x480;
+        nds_bezels = "resources/bg/800x480/";
+    } else if (rect.w == 854 && rect.h == 480) {
+        res_sel = disp_854x480;
+        nds_bezels = "resources/bg/854x480/";
+    } else if (rect.w == 720 && rect.h == 480) {
+        res_sel = disp_720x480;
+        nds_bezels = "resources/bg/720x480/";
+    } else if (rect.w == 480 && rect.h == 320) {
+        res_sel = disp_480x320;
+        nds_bezels = "resources/bg/480x320/";
+    }
+
+    if (!res_sel || !nds_bezels) {
+        printf("Unsupported output resolution.\n");
+        return;
+    }
+    disp_rect = rect;
+
+
+	/* Load background png if valid. Execpt menu. */
+    for (i = 0; i < DISP_TGT_MODE_MAX - 1; i++) {
+        snprintf(texpath, sizeof(texpath), "%s%s", nds_bezels, nds_bg_png[i]);
+        res_sel[i].bg_tex = loadBackground(texpath, mRenderer);
+    }
+
+	/* First initialize the layouts with first 2 layouts. */
+	nds_disp_resize_used[DISP_MODE_H] = res_sel[DISP_TGT_MODE_TOP_FULL];
+	nds_disp_resize_used[DISP_MODE_V] = res_sel[DISP_TGT_MODE_V_ORI];
+	nds_disp_resize_used[DISP_MODE_H_SINGLE] = res_sel[DISP_TGT_MODE_H_SINGLE];
+	nds_disp_resize_used[DISP_MODE_H_SINGLE] = res_sel[DISP_TGT_MODE_H_SINGLE];
+	nds_disp_resize_used[DISP_MODE_MENU] = res_sel[DISP_TGT_MODE_MENU];
+
+	/* Select the screen layout with bg texture if has. */
+	for (i = 2; i < DISP_TGT_MODE_MAX - 2; i++) {
+		/* The bg textures are ready for now. */
+		if (nds_disp_resize_used[DISP_MODE_H].bg_tex &&
+			nds_disp_resize_used[DISP_MODE_V].bg_tex)
+			break;
+
+		/* If the candicate layout does not have bg_tex, skip that layout as low priority. */
+		if (!res_sel[i].bg_tex)
+			continue;
+
+		/* Replace no bg_tex pre-layout if candicate layouts have bg_tex. */
+		if (!nds_disp_resize_used[DISP_MODE_H].bg_tex &&
+			!nds_disp_resize_used[DISP_MODE_V].bg_tex)
+			nds_disp_resize_used[DISP_MODE_H] = res_sel[i];
+		else if (nds_disp_resize_used[DISP_MODE_H].bg_tex &&
+			!nds_disp_resize_used[DISP_MODE_V].bg_tex)
+			nds_disp_resize_used[DISP_MODE_V] = res_sel[i];
+		else if (!nds_disp_resize_used[DISP_MODE_H].bg_tex &&
+			nds_disp_resize_used[DISP_MODE_V].bg_tex)
+			nds_disp_resize_used[DISP_MODE_H] = res_sel[i];
+	}
+
+	/* Start generate the pointer scale value. */
+	for (i = 0; i < DISP_MODE_MAX - 1; i++) {
+		nds_disp_resize_used[i].pointer_scale[0] = (float)nds_disp_resize_used[i].tgt_rect[0].w / NDS_DRASTIC_H;
+		nds_disp_resize_used[i].pointer_scale[1] = (float)nds_disp_resize_used[i].tgt_rect[1].w / NDS_DRASTIC_H;
+	}
+}
+
+static void nds_drastic_update_disp_mode(SDL_Renderer *renderer, int w, int h)
+{
+    static int layout_step = -1;  // -1 表示还没初始化
+
+    printf("[nds] update_disp_mode: w=%d h=%d\n", w, h);
+
+    /* 你原来那套分辨率 -> disp_mode 的逻辑，保持基本不动 */
+    if ((w == 512 && h == 192) || (w == 640 && h == 240)) {
+        disp_mode = DISP_MODE_H;
+    } else if (h == 480 && w == 800 && res_sel != disp_800x480) {
+        disp_mode = DISP_MODE_MENU;
+    } else if ((w == 256 && h == 384) || (w == 320 && h == 480)) {
+        disp_mode = DISP_MODE_V;
+    } else if ((w == 256 && h == 192) || (w == 320 && h == 240)) {
+        disp_mode = DISP_MODE_H_SINGLE;
+    }
+
+    if (res_sel) {
+        if ((disp_mode == DISP_MODE_H || disp_mode == DISP_MODE_V) &&
+            !(w == disp_rect.w && h == disp_rect.h)) {
+
+            // layout_step = (layout_step + 1) % 3;
+            layout_step = (layout_step + 1) % 4; //四切
+
+            static const int cycle[4] = {
+                DISP_TGT_MODE_TOP_FULL,        // 0: FULL (bg_vertical_full.png)
+                DISP_TGT_MODE_TOP_CONN_BOTTOM, // 1: EXT  (bg_vertical_ext.png)
+                DISP_TGT_MODE_V_ORI,           // 2: ORI  (bg_vertical.png)
+                DISP_TGT_MODE_TRANSPARENT,             // 3: 2DS  (bg_vertical_2ds.png) 四切换
+            };
+
+            printf("[nds] layout_step=%d -> cycle=%d\n",
+                   layout_step, cycle[layout_step]);
+
+            nds_is_overlapping_layout = (DISP_TGT_MODE_TRANSPARENT == cycle[layout_step]);
+            nds_disp_resize_used[DISP_MODE_H] = res_sel[cycle[layout_step]];
+            nds_disp_resize_used[DISP_MODE_V] = res_sel[cycle[layout_step]];
+        }
+        renderer->logical_w = disp_rect.w;
+        renderer->logical_h = disp_rect.h;
+    }
+
+    system("swaymsg [app_id='drastic'] fullscreen enable");
+}
+
+
+
 static SDL_INLINE void DebugLogRenderCommands(const SDL_RenderCommand *cmd)
 {
 #if 0
@@ -954,6 +2006,67 @@ static void SDL_CalculateSimulatedVSyncInterval(SDL_Renderer *renderer, SDL_Wind
 }
 #endif /* !SDL_RENDER_DISABLED */
 
+void sdl_print_string(char *p, uint32_t fg, uint32_t bg, uint32_t x, uint32_t y)
+{
+    int w = 0, h = 0;
+    SDL_Color col = {0};
+    SDL_Surface *t0 = NULL;
+    SDL_Surface *t1 = NULL;
+    static int fps_cnt = 0;
+
+    if (res_sel == disp_800x480)
+	    disp_mode = DISP_MODE_MENU;
+
+    if (p && (strlen(p) > 0)) {
+        if (drastic_menu.cnt < MAX_MENU_LINE) {
+            drastic_menu.item[drastic_menu.cnt].x = x;
+            drastic_menu.item[drastic_menu.cnt].y = y;
+            drastic_menu.item[drastic_menu.cnt].fg = fg;
+            drastic_menu.item[drastic_menu.cnt].bg = bg;
+            strcpy(drastic_menu.item[drastic_menu.cnt].msg, p);
+            drastic_menu.cnt+= 1;
+        }
+        //printf(PREFIX"x:%d, y:%d, fg:0x%x, bg:0x%x, \'%s\'\n", x, y, fg, bg, p);
+    }
+#if 0
+    if ((x == 0) && (y == 0) && (fg == 0xffff) && (bg == 0x0000)) {
+        if (fps_cnt++ > 60) {
+            fps_cnt = 0;
+
+            w = strlen(p);
+            for (h=w-1; h>=0; h--) {
+                if (p[h] == ' ') {
+                    p[h] = 0;
+                    break;
+                }
+            }
+
+            col.r = 0xcc;
+            col.g = 0xcc;
+            col.b = 0x00;
+            TTF_SizeUTF8(nds.font, p, &w, &h);
+            t0 = TTF_RenderUTF8_Solid(nds.font, p, col);
+            if (t0) {
+                t1 = SDL_CreateRGBSurface(SDL_SWSURFACE, t0->w, t0->h, 32, 0, 0, 0, 0);
+                if (t1) {
+                    SDL_FillRect(t1, &t1->clip_rect, 0x000000);
+                    SDL_BlitSurface(t0, NULL, t1, NULL);
+
+                    if (fps_info) {
+                        SDL_FreeSurface(fps_info);
+                    }
+                    fps_info = SDL_ConvertSurface(t1, cvt->format, 0);
+                    SDL_FreeSurface(t1);
+                }
+                SDL_FreeSurface(t0);
+            }
+            show_fps = 1;
+        }
+    }
+#endif
+}
+
+
 SDL_Renderer *SDL_CreateRenderer(SDL_Window *window, int index, Uint32 flags)
 {
 #ifndef SDL_RENDER_DISABLED
@@ -1127,6 +2240,9 @@ SDL_Renderer *SDL_CreateRenderer(SDL_Window *window, int index, Uint32 flags)
 #if defined(__ANDROID__)
     Android_ActivityMutex_Unlock();
 #endif
+
+    nds_drastic_init(renderer, window);
+
     return renderer;
 
 error:
@@ -2447,6 +3563,8 @@ int SDL_RenderSetLogicalSize(SDL_Renderer *renderer, int w, int h)
     renderer->logical_w = w;
     renderer->logical_h = h;
 
+	nds_drastic_update_disp_mode(renderer, w, h);
+
     return UpdateLogicalSize(renderer, SDL_TRUE);
 }
 
@@ -3423,11 +4541,1049 @@ int SDL_RenderFillRectsF(SDL_Renderer *renderer,
     return retval < 0 ? retval : FlushRenderCommandsIfNotBatching(renderer);
 }
 
+static inline int SDL_RenderCopy_nds(SDL_Renderer *renderer, SDL_Texture *texture,
+                   const SDL_Rect *str, const SDL_Rect *dtr)
+{
+    SDL_FRect dstfrect;
+    SDL_FRect *pdstfrect = NULL;
+
+    dstfrect.x = (float)dtr->x;
+    dstfrect.y = (float)dtr->y;
+    dstfrect.w = (float)dtr->w;
+    dstfrect.h = (float)dtr->h;
+    pdstfrect = &dstfrect;
+
+    return SDL_RenderCopyF(renderer, texture, str, pdstfrect);
+}
+
+static inline bool nds_tex_is_pointer(const SDL_Texture *texture)
+{
+	return (texture->w == 32 && texture->h == 32);
+}
+
+static inline bool nds_pointer_in_first_screen(const SDL_Rect *dstrect)
+{
+	return (dstrect->x < 256 && dstrect->y < 192);
+}
+
+static inline bool nds_rect_is_first_screen(const SDL_Rect *dstrect)
+{
+	return (dstrect->x == 0 && dstrect->y == 0);
+}
+
+const char *to_lang(const char *p)
+{
+    const char *info = p;
+    char buf[MAX_PATH] = {0};
+    int cc = 0, r = 0, len = 0;
+    
+    if (!strcmp(nds.lang.trans[DEF_LANG_SLOT], DEF_LANG_LANG) || (p == NULL)) {
+        return p;
+    }
+
+    strcpy(buf, p);
+    strcat(buf, "=");
+    len = strlen(buf);
+    if ((len == 0) || (len >= MAX_PATH)) {
+        return 0;
+    }
+
+    for (cc=0; translate[cc]; cc++) {
+        if (memcmp(buf, translate[cc], len) == 0) {
+            r = 1;
+            info = &translate[cc][len];
+            //printf(PREFIX"Translate \'%s\' as \'%s\'\n", p, info);
+            break;
+        }
+    }
+
+    if (r == 0) {
+        printf(PREFIX"Failed to find the translation: \'%s\'(len=%d)\n", p, len);
+        info = p;
+    }
+    return info;
+}
+
+int draw_info(SDL_Surface *dst, const char *info, int x, int y, uint32_t fgcolor, uint32_t bgcolor)
+{
+    int w = 0, h = 0;
+    SDL_Color fg = {0};
+    SDL_Rect rt = {0, 0, 0, 0};
+    SDL_Surface *t0 = NULL;
+    SDL_Surface *t1 = NULL;
+    SDL_Surface *t2 = NULL;
+
+    h = strlen(info);
+    if ((nds.font == NULL) || (h == 0) || (h >= MAX_PATH)) {
+	printf("incorrect input\n");
+        return -1;
+    }
+
+    fg.r = (fgcolor >> 16) & 0xff;
+    fg.g = (fgcolor >> 8) & 0xff;
+    fg.b = (fgcolor >> 0) & 0xff;
+    TTF_SizeUTF8(nds.font, info, &w, &h);
+    t0 = TTF_RenderUTF8_Solid(nds.font, info, fg);
+    if (t0) {
+        rt.x = x;
+        rt.y = y;
+        if (SDL_BlitSurface(t0, NULL, dst, &rt))
+		printf("Blit suface failed\n");
+        SDL_FreeSurface(t0);
+    } else {
+	printf("TTF_RenderUTF8_Solid failed\n");
+    }
+
+    return 0;
+}
+
+static int get_current_menu_layer(void)
+{
+    int cc = 0;
+    const char *P0 = "Change Options";
+    const char *P1 = "Frame skip type";
+    const char *P2 = "D-Pad Up";
+    const char *P3 = "Enter Menu";
+    const char *P4 = "Username";
+    //const char *P5 = "KB Space: toggle cheat/folder    KB Left Ctrl: return to main menu";
+    const char *P50 = "toggle cheat/folder";
+    const char *P51 = "return to main menu";
+    const char *P6 = "KB Space: select";
+
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (!memcmp(drastic_menu.item[cc].msg, P0, strlen(P0))) {
+            return NDS_DRASTIC_MENU_MAIN;
+        }
+        else if (!memcmp(drastic_menu.item[cc].msg, P1, strlen(P1))) {
+            return NDS_DRASTIC_MENU_OPTION;
+        }
+        else if (!memcmp(drastic_menu.item[cc].msg, P2, strlen(P2))) {
+            return NDS_DRASTIC_MENU_CONTROLLER;
+        }
+        else if (!memcmp(drastic_menu.item[cc].msg, P3, strlen(P3))) {
+            return NDS_DRASTIC_MENU_CONTROLLER2;
+        }
+        else if (!memcmp(drastic_menu.item[cc].msg, P4, strlen(P4))) {
+            return NDS_DRASTIC_MENU_FIRMWARE;
+        }
+        else if (strstr(drastic_menu.item[cc].msg, P50) || strstr(drastic_menu.item[cc].msg, P51)) {
+            return NDS_DRASTIC_MENU_CHEAT;
+        }
+        else if (!memcmp(drastic_menu.item[cc].msg, P6, strlen(P6))) {
+            return NDS_DRASTIC_MENU_ROM;
+        }
+    }
+
+    printf("Dump the incrrect menu msg:\n");
+    for (cc=0; cc<drastic_menu.cnt; cc++)
+	printf("%d: %s\n", cc, drastic_menu.item[cc].msg);
+
+    return -1;
+}
+
+int get_font_width(const char *info)
+{
+    int w = 0, h = 0;
+
+    if (nds.font && info) {
+	    TTF_SizeUTF8(nds.font, info, &w, &h);
+    }
+    return w;
+}
+
+static int draw_drastic_menu_main(void)
+{
+    int cc = 0;
+    int div = 1;
+    int w = 30;
+    int h = 100;
+    int draw = 0;
+    int draw_shot = 0;
+    int x = 0, y = 0;
+    SDL_Rect rt = {0};
+    CUST_MENU_SUB *p = NULL;
+    char buf[MAX_PATH << 1] = {0};
+
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        draw = 0;
+        x = 90 / div;
+        w = LINE_H / div;
+        h = 100 / div;
+
+        memset(buf, 0, sizeof(buf));
+        p = &drastic_menu.item[cc];
+        if (p->y == 201) {
+            draw = 1;
+            sprintf(buf, "%s", &p->msg[8]);
+            x = FB_W - get_font_width(buf) - 10;
+            y = 10 / div;
+        }
+        else if (p->y == 280) {
+            draw = 1;
+            y = h + (0 * w);
+            strcpy(buf, to_lang("Change Options"));
+        }
+        else if (p->y == 288) {
+            draw = 1;
+            y = h + (1 * w);
+            strcpy(buf, to_lang("Configure Controls"));
+        }
+        else if (p->y == 296) {
+            draw = 1;
+            y = h + (2 * w);
+            strcpy(buf, to_lang("Configure Firmware"));
+        }
+        else if (p->y == 304) {
+            draw = 1;
+            y = h + (3 * w);
+            strcpy(buf, to_lang("Configure Cheats"));
+        }
+        else if (p->y == 320) {
+            draw = 1;
+            y = h + (4 * w);
+            sprintf(buf, "%s %s", to_lang("Load state"), &p->msg[13]);
+        }
+        else if (p->y == 328) {
+            draw = 1;
+            y = h + (5 * w);
+            sprintf(buf, "%s %s", to_lang("Save state"), &p->msg[13]);
+        }
+        else if (p->y == 344) {
+            draw = 1;
+            y = h + (6 * w);
+            strcpy(buf, to_lang("Load new game"));
+        }
+        else if (p->y == 352) {
+            draw = 1;
+            y = h + (7 * w);
+            strcpy(buf, to_lang("Restart game"));
+        }
+        else if (p->y == 368) {
+            draw = 1;
+            y = h + (8 * w);
+            strcpy(buf, to_lang("Return to game"));
+        }
+        else if (p->y == NDS_Hx2) {
+            draw = 1;
+            y = h + (9 * w);
+            strcpy(buf, to_lang("Exit DraStic"));
+        }
+
+        if (draw) {
+            if (p->bg) {
+                rt.x = 5 / div;
+                rt.y = y - (3 / div);
+                rt.w = FB_W - (10 / div);
+                rt.h = w;
+                SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, 
+                    (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+                if ((p->y == 320) || (p->y == 328)) {
+                    draw_shot = 1;
+                }
+
+                if (nds.menu.drastic.cursor) {
+                    rt.x = (5 / div) + (x - nds.menu.drastic.cursor->w) / 2;
+                    rt.y -= ((nds.menu.drastic.cursor->h - LINE_H) / 2);
+                    rt.w = 0;
+                    rt.h = 0;
+                    SDL_BlitSurface(nds.menu.drastic.cursor, NULL, nds.menu.drastic.main, &rt);
+                }
+            }
+            draw_info(nds.menu.drastic.main, buf, x, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+        }
+    }
+
+    y = 10;
+    sprintf(buf, "%s", "\x50\x6F\x77\x65\x72\x65\x64\x20\x62\x79\x20\x41\x72\x6B\x4F\x53\x34\x43\x6C\x6F\x6E\x65\x20\xC2\xB7\x20\x50\x61\x74\x63\x68\x20\x62\x79\x20\x4B\x4B");
+    draw_info(nds.menu.drastic.main, buf, 10, y / div, nds.menu.c1, 0);
+#if 0
+    if (draw_shot) {
+        const uint32_t len = NDS_W * NDS_H * 2;
+        uint16_t *top = malloc(len);
+        uint16_t *bottom = malloc(len);
+
+        if (top && bottom) {
+            SDL_Surface *t = NULL;
+
+            uint32_t slot = *((uint32_t *)VAR_SYSTEM_SAVESTATE_NUM);
+            nds_load_state_index _func = (nds_load_state_index)FUN_LOAD_STATE_INDEX;
+
+            memset(top, 0, len);
+            memset(bottom, 0, len);
+            _func((void*)VAR_SYSTEM, slot, top, bottom, 1);
+            t = SDL_CreateRGBSurfaceFrom(top, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
+            if (t) {
+                rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
+                rt.y = nds.enable_752x560 ? h - 20 : 50;
+                rt.w = NDS_W;
+                rt.h = NDS_H;
+                SDL_BlitSurface(t, NULL, nds.menu.drastic.main, &rt);
+                SDL_FreeSurface(t);
+            }
+
+            t = SDL_CreateRGBSurfaceFrom(bottom, NDS_W, NDS_H, 16, NDS_W * 2, 0, 0, 0, 0);
+            if (t) {
+                rt.x = FB_W - (NDS_W + (nds.enable_752x560 ? 30 : 10));
+                rt.y = nds.enable_752x560 ? (h + NDS_H) - 20 : 50 + NDS_H;
+                rt.w = NDS_W;
+                rt.h = NDS_H;
+                SDL_BlitSurface(t, NULL, nds.menu.drastic.main, &rt);
+                SDL_FreeSurface(t);
+            }
+        }
+
+        if (top) {
+            free(top);
+        }
+
+        if (bottom) {
+            free(bottom);
+        }
+    }
+#endif
+    return 0;
+}
+
+static int mark_double_spaces(char *p)
+{
+    int cc = 0;
+    int len = strlen(p);
+
+    for (cc=0; cc<len - 1; cc++) {
+        if ((p[cc] == ' ') && (p[cc + 1] == ' ')) {
+            p[cc] = 0;
+            return 0;
+        }
+    }
+    return -1;
+}
+
+static char* find_menu_string_tail(char *p)
+{
+    int cc = 0;
+
+    for (cc=strlen(p) - 1; cc>=0; cc--) {
+        if (p[cc] == ' ') {
+            return &p[cc + 1];
+        }
+    }
+    return NULL;
+}
+
+
+static int draw_drastic_menu_cheat(void)
+{
+    int y = 0;
+    int w = 30;
+    int cc = 0;
+    int div = 1;
+    int cnt = 0;
+    int cursor = 0;
+    SDL_Rect rt = {0};
+    int s0 = 0, s1 = 0;
+    CUST_MENU_SUB *p = NULL;
+    char buf[MAX_PATH] = {0};
+
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        p = &drastic_menu.item[cc];
+        if (p->x == 650) {
+            for (s0=0; s0<drastic_menu.cnt; s0++) {
+                if ((drastic_menu.item[s0].x == 10) && (drastic_menu.item[s0].y == p->y)) {
+                    drastic_menu.item[s0].cheat = 1;
+                    drastic_menu.item[s0].enable = strcmp(p->msg, "enabled") == 0 ? 1 : 0;
+                    break;
+                }
+            }
+        }
+    }
+
+    s0 = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].x == 10) {
+            memcpy(&drastic_menu.item[s0], &drastic_menu.item[cc], sizeof(drastic_menu.item[cc]));
+            s0+= 1;
+        }
+        memset(&drastic_menu.item[cc], 0, sizeof(drastic_menu.item[cc]));
+    }
+    drastic_menu.cnt = s0;
+
+    cursor = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].bg > 0) {
+            cursor = cc;
+        }
+    }
+
+    if (drastic_menu.cnt == 0) {
+        return 0;
+    }
+
+    if (drastic_menu.cnt < 13) {
+        s0 = 0;
+        s1 = drastic_menu.cnt;
+    }
+    else if (cursor <= 6) {
+        s0 = 0;
+        s1 = 13;
+    }
+    else if (cursor >= (drastic_menu.cnt - 7)) {
+        s0 = drastic_menu.cnt - 13;
+        s1 = drastic_menu.cnt;
+    }
+    else {
+        s0 = cursor - 6;
+        s1 = cursor + 7;
+    }
+
+    cnt = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        w = LINE_H / div;
+        memset(buf, 0, sizeof(buf));
+        p = &drastic_menu.item[cc];
+
+        if (p->x != 10) {
+            continue;
+        }
+
+        if ((cc >= s0) && (cc < s1)) {
+            y = (25 / div) + (cnt * w);
+
+            if (p->bg) {
+                rt.x = 5 / div;
+                rt.y = y - (3 / div);
+                rt.w = FB_W - (10 / div);
+                rt.h = w;
+                SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format,
+                    (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+            }
+
+            cnt+= 1;
+            draw_info(nds.menu.drastic.main, p->msg, w / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+            if (p->cheat && nds.menu.drastic.yes && nds.menu.drastic.no) {
+                rt.x = FB_W - nds.menu.drastic.yes->w - (w / div);
+                rt.y = y - 1;
+                rt.w = 0;
+                rt.h = 0;
+                SDL_BlitSurface((p->enable > 0 ) ? nds.menu.drastic.yes : nds.menu.drastic.no, NULL, nds.menu.drastic.main, &rt);
+            }
+        }
+    }
+    return 0;
+}
+
+static int draw_drastic_menu_rom(void)
+{
+    int y = 0;
+    int w = 0;
+    int cc = 0;
+    int div = 1;
+    int chk = 0;
+    int all = 0;
+    int cnt = 0;
+    int cursor = 0;
+    SDL_Rect rt = {0};
+    int s0 = 0, s1 = 0;
+    CUST_MENU_SUB *p = NULL;
+
+
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].x == 10) {
+            if (drastic_menu.item[cc].bg > 0) {
+                chk = 10;
+                break;
+            }
+        }
+        if (drastic_menu.item[cc].x == 587) {
+            if (drastic_menu.item[cc].bg > 0) {
+                chk = 587;
+                break;
+            }
+        }
+    }
+
+    cursor = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].x == chk) {
+            if (drastic_menu.item[cc].bg > 0) {
+                break;
+            }
+            cursor+= 1;
+        }
+    }
+
+    all = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].x == chk) {
+            all+= 1;
+        }
+    }
+
+    if (all < 12) {
+        s0 = 0;
+        s1 = all;
+    }
+    else if (cursor <= 6) {
+        s0 = 0;
+        s1 = 12;
+    }
+    else if (cursor >= (all - 6)) {
+        s0 = all - 12;
+        s1 = all;
+    }
+    else {
+        s0 = cursor - 6;
+        s1 = cursor + 6;
+    }
+
+    {
+        uint32_t c = 0x335445;
+
+        w = LINE_H / div;
+        p = &drastic_menu.item[0];
+        rt.x = 5 / div;
+        rt.y = (25 / div) - (4 / div);
+        rt.w = FB_W - (10 / div);
+        rt.h = w;
+        SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, (c >> 16) & 0xff, (c >> 8) & 0xff, c & 0xff));
+        draw_info(nds.menu.drastic.main, p->msg, 20 / div, 25 / div, 0xa0cb93, 0);
+    }
+
+    cnt = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        w = LINE_H / div;
+        p = &drastic_menu.item[cc];
+        if (p->x == chk) {
+            y = (25 / div) + (((cnt - s0) + 1) * w);
+            if ((cnt >= s0) && (cnt < s1)) {
+                if (p->bg) {
+                    rt.x = 5 / div;
+                    rt.y = y - (4 / div);
+                    rt.w = FB_W - (10 / div);
+                    rt.h = w;
+                    SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format,
+                        (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+                }
+                draw_info(nds.menu.drastic.main, p->msg, 20 / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+            }
+            cnt+= 1;
+        }
+    }
+    return 0;
+}
+
+static int draw_drastic_menu_firmware(void)
+{
+    int t = 0;
+    int w = 0;
+    int y = 0;
+    int ww = 30;
+    int cc = 0;
+    int div = 1;
+    int cnt = 0;
+    SDL_Rect rt = {0};
+    CUST_MENU_SUB *p = NULL;
+    char buf[MAX_PATH] = {0};
+    char name[MAX_PATH] = {0};
+
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        ww = LINE_H / div;
+        p = &drastic_menu.item[cc];
+        if ((p->x == 352) || (p->x == 108)) {
+            continue;
+        }
+    
+        memset(buf, 0, sizeof(buf));
+        if ((p->x != 92) && (p->x != 256)) {
+            strcat(name, p->msg);
+        }
+        else {
+            y = (25 / div) + (cnt * ww);
+            if (((p->x == 92) || (p->x == 256)) && (p->bg)) {
+                rt.x = 5 / div;
+                rt.y = y - (3 / div);
+                rt.w = FB_W - (10 / div);
+                rt.h = ww;
+                SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, 
+                    (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+            }
+
+            cnt+= 1;
+            if (p->y == 280) {
+                mark_double_spaces(p->msg);
+                strcpy(buf, to_lang(p->msg));
+            }
+            else if (p->y == 296) {
+                w = get_font_width(name);
+                draw_info(nds.menu.drastic.main, name, FB_W - w - (ww / div), 25 / div, nds.menu.c1, 0);
+
+                w = strlen(p->msg);
+                p->msg[w - 3] = 0;
+                for (t=14; t<w; t++) {
+                    if (p->msg[t] != ' ') {
+                        strcpy(buf, &p->msg[t]);
+                        break;
+                    }
+                }
+                w = get_font_width(buf);
+                draw_info(nds.menu.drastic.main, buf, FB_W - w - (ww / div), y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+
+                strcpy(buf, to_lang("Favorite Color"));
+            }
+            else if (p->y <= 312) {
+                strcpy(buf, to_lang(find_menu_string_tail(p->msg)));
+                w = get_font_width(buf);
+                draw_info(nds.menu.drastic.main, buf, FB_W - w - (ww / div), y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+
+                mark_double_spaces(p->msg);
+                strcpy(buf, to_lang(p->msg));
+            }
+            else {
+                strcpy(buf, to_lang(p->msg));
+            }
+            draw_info(nds.menu.drastic.main, buf, ww / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+        }
+    }
+    return 0;
+}
+
+static int draw_drastic_menu_controller2(void)
+{
+    int y = 0;
+    int w = 0;
+    int cc = 0;
+    int cnt = 0;
+    int div = 1;
+    int cursor = 0;
+    SDL_Rect rt = {0};
+    int s0 = 0, s1 = 0;
+    CUST_MENU_SUB *p = NULL;
+    char buf[MAX_PATH] = {0};
+
+    cursor = 0;
+    for (cc=0; cc<drastic_menu.cnt;) {
+        if ((drastic_menu.item[cc].y >= 240) && (drastic_menu.item[cc].y <= NDS_Hx2)) {
+            if ((drastic_menu.item[cc + 1].bg > 0) || (drastic_menu.item[cc + 2].bg > 0)) {
+                break;
+            }
+            cc+= 3;
+        }
+        else {
+            if (drastic_menu.item[cc].bg > 0) {
+                break;
+            }
+            cc+= 1;
+        }
+        cursor+= 1;
+    }
+    
+    if (cursor <= 6) {
+        s0 = 0;
+        s1 = 13;
+    }
+    else if (cursor >= (23 - 7)) {
+        s0 = 23 - 13;
+        s1 = 23;
+    }
+    else {
+        s0 = cursor - 6;
+        s1 = cursor + 7;
+    }
+
+    cnt = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        w = LINE_H / div;
+        p = &drastic_menu.item[cc];
+
+        if ((p->y == 224) || (p->y == 232) || (p->y == 201)) {
+            continue;
+        }
+
+        memset(buf, 0, sizeof(buf));
+        if ((cnt >= s0) && (cnt < s1)) {
+            y = (25 / div) + ((cnt - s0) * w);
+
+            if ((p->y >= 240) && (p->y <= NDS_Hx2)) {
+                if (drastic_menu.item[cc + 1].bg || drastic_menu.item[cc + 2].bg) {
+                    int sum = drastic_menu.item[cc + 1].bg + drastic_menu.item[cc + 2].bg;
+                    uint32_t c = sum > 500 ? 0xff0000 : nds.menu.c2;
+
+                    rt.x = 5 / div;
+                    rt.y = y - (3 / div);
+                    rt.w = FB_W - (10 / div);
+                    rt.h = w;
+                    SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, (c >> 16) & 0xff, (c >> 8) & 0xff, c & 0xff));
+                }
+                draw_info(nds.menu.drastic.main, p->msg, 20 / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+                if ((p->y >= 240) && (p->y <= NDS_Hx2)) {
+                        draw_info(nds.menu.drastic.main, to_lang(drastic_menu.item[cc + 1].msg), 300 / div, y, drastic_menu.item[cc + 1].bg ? nds.menu.c0 : nds.menu.c1, 0);
+                        draw_info(nds.menu.drastic.main, to_lang(drastic_menu.item[cc + 2].msg), 480 / div, y, drastic_menu.item[cc + 2].bg ? nds.menu.c0 : nds.menu.c1, 0);
+                }
+            }
+            else {
+                if (p->bg) {
+                    rt.x = 5 / div;
+                    rt.y = y - (3 / div);
+                    rt.w = FB_W - (10 / div);
+                    rt.h = w;
+                    SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, 
+                        (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+                }
+                draw_info(nds.menu.drastic.main, to_lang(p->msg), 20 / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+            }
+        }
+
+        cnt+= 1;
+        if ((p->y >= 240) && (p->y <= NDS_Hx2)) {
+            cc+= 2;
+        }
+    }
+    return 0;
+}
+
+static int draw_drastic_menu_controller(void)
+{
+    int y = 0;
+    int w = 0;
+    int cc = 0;
+    int div = 1;
+    int cnt = 0;
+    int cursor = 0;
+    SDL_Rect rt = {0};
+    int s0 = 0, s1 = 0;
+    CUST_MENU_SUB *p = NULL;
+    char buf[MAX_PATH] = {0};
+
+    cursor = 0;
+    for (cc=0; cc<drastic_menu.cnt;) {
+        if ((drastic_menu.item[cc].y >= 240) && (drastic_menu.item[cc].y <= 376)) {
+            if ((drastic_menu.item[cc + 1].bg > 0) || (drastic_menu.item[cc + 2].bg > 0)) {
+                break;
+            }
+            cc+= 3;
+        }
+        else {
+            if (drastic_menu.item[cc].bg > 0) {
+                break;
+            }
+            cc+= 1;
+        }
+        cursor+= 1;
+    }
+    
+    if (cursor <= 6) {
+        s0 = 0;
+        s1 = 13;
+    }
+    else if (cursor >= (24 - 7)) {
+        s0 = 24 - 13;
+        s1 = 24;
+    }
+    else {
+        s0 = cursor - 6;
+        s1 = cursor + 7;
+    }
+
+    cnt = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        w = LINE_H / div;
+        p = &drastic_menu.item[cc];
+
+        if ((p->y == 224) || (p->y == 232) || (p->y == 201)) {
+            continue;
+        }
+
+        memset(buf, 0, sizeof(buf));
+        if ((cnt >= s0) && (cnt < s1)) {
+            y = (25 / div) + ((cnt - s0) * w);
+
+            if ((p->y >= 240) && (p->y <= 376)) {
+                if (drastic_menu.item[cc + 1].bg || drastic_menu.item[cc + 2].bg) {
+                    int sum = drastic_menu.item[cc + 1].bg + drastic_menu.item[cc + 2].bg;
+                    uint32_t c = sum > 500 ? 0xff0000 : nds.menu.c2;
+
+                    rt.x = 5 / div;
+                    rt.y = y - (3 / div);
+                    rt.w = FB_W - (10 / div);
+                    rt.h = w;
+                    SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, (c >> 16) & 0xff, (c >> 8) & 0xff, c & 0xff));
+                }
+                draw_info(nds.menu.drastic.main, p->msg, 20 / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+                if ((p->y >= 240) && (p->y <= 376)) {
+                        draw_info(nds.menu.drastic.main, to_lang(drastic_menu.item[cc + 1].msg), 300 / div, y, drastic_menu.item[cc + 1].bg ? nds.menu.c0 : nds.menu.c1, 0);
+                        draw_info(nds.menu.drastic.main, to_lang(drastic_menu.item[cc + 2].msg), 480 / div, y, drastic_menu.item[cc + 2].bg ? nds.menu.c0 : nds.menu.c1, 0);
+                }
+            }
+            else {
+                if (p->bg) {
+                    rt.x = 5 / div;
+                    rt.y = y - (3 / div);
+                    rt.w = FB_W - (10 / div);
+                    rt.h = w;
+                    SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, 
+                        (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+                }
+                draw_info(nds.menu.drastic.main, to_lang(p->msg), 20 / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+            }
+        }
+
+        cnt+= 1;
+        if ((p->y >= 240) && (p->y <= 376)) {
+            cc+= 2;
+        }
+    }
+    return 0;
+}
+static int draw_drastic_menu_option(void)
+{
+    int w = 0;
+    int y = 0;
+    int ww = 0;
+    int s0 = 0;
+    int s1 = 0;
+    int cc = 0;
+    int div = 1;
+    int cnt = 0;
+    int cursor = 0;
+    SDL_Rect rt = {0};
+    CUST_MENU_SUB *p = NULL;
+    char buf[MAX_PATH] = {0};
+
+    cursor = 0;
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        if (drastic_menu.item[cc].bg > 0) {
+            cursor = cc;
+        }
+    }
+
+    if (cursor <= 6) {
+        s0 = 1;
+        s1 = 14;
+    }
+    else if (cursor >= (drastic_menu.cnt - 7)) {
+        s0 = drastic_menu.cnt - 14;
+        s1 = drastic_menu.cnt - 1;
+    }
+    else {
+        s0 = cursor - 6;
+        s1 = cursor + 7;
+    }
+
+    for (cc=0; cc<drastic_menu.cnt; cc++) {
+        ww = LINE_H / div;
+
+        if ((cc >= s0) && (cc < s1)) {
+            y = (25 / div) + (cnt * ww);
+            memset(buf, 0, sizeof(buf));
+            p = &drastic_menu.item[cc];
+        
+            cnt+= 1;            
+            if (p->bg) {
+                rt.x = 5 / div;
+                rt.y = y - (3 / div);
+                rt.w = FB_W - (10 / div);
+                rt.h = ww;
+                SDL_FillRect(nds.menu.drastic.main, &rt, SDL_MapRGB(nds.menu.drastic.main->format, 
+                    (nds.menu.c2 >> 16) & 0xff, (nds.menu.c2 >> 8) & 0xff, nds.menu.c2 & 0xff));
+            }
+
+            if (p->y <= NDS_Hx2) {
+                strcpy(buf, to_lang(find_menu_string_tail(p->msg)));
+                w = get_font_width(buf);
+                draw_info(nds.menu.drastic.main, buf, FB_W - w - (ww / div), y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+
+                mark_double_spaces(p->msg);
+                strcpy(buf, to_lang(p->msg));
+            }
+            else {
+                strcpy(buf, to_lang(p->msg));
+            }
+            draw_info(nds.menu.drastic.main, buf, ww / div, y, p->bg ? nds.menu.c0 : nds.menu.c1, 0);
+        }
+    }
+    return 0;
+}
+
+int process_drastic_menu(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_Rect *dstrect)
+{
+    int layer = get_current_menu_layer();
+    SDL_FRect dstfrect;
+
+
+    if (!drastic_menu.cnt) {
+	    printf("Skip emtpy\n");
+	    return 0;
+    }
+
+    dstfrect.x = (float)dstrect->x;
+    dstfrect.y = (float)dstrect->y;
+    dstfrect.w = (float)dstrect->w;
+    dstfrect.h = (float)dstrect->h;
+
+    if (layer == NDS_DRASTIC_MENU_MAIN) {
+        SDL_SoftStretch(nds.menu.drastic.bg0, NULL, nds.menu.drastic.main, NULL);
+    }
+    else {
+        SDL_SoftStretch(nds.menu.drastic.bg1, NULL, nds.menu.drastic.main, NULL);
+    }
+
+    switch (layer) {
+    case NDS_DRASTIC_MENU_MAIN:
+        draw_drastic_menu_main();
+        break;
+    case NDS_DRASTIC_MENU_OPTION:
+        draw_drastic_menu_option();
+        break;
+    case NDS_DRASTIC_MENU_CONTROLLER:
+        draw_drastic_menu_controller();
+        break;
+    case NDS_DRASTIC_MENU_CONTROLLER2:
+        draw_drastic_menu_controller2();
+        break;
+    case NDS_DRASTIC_MENU_FIRMWARE:
+        draw_drastic_menu_firmware();
+        break;
+    case NDS_DRASTIC_MENU_CHEAT:
+        draw_drastic_menu_cheat();
+        break;
+    case NDS_DRASTIC_MENU_ROM:
+        draw_drastic_menu_rom();
+        break;
+    default:
+	break;
+    }
+
+    //printf("in the layer:%d\n", layer);
+    SDL_UpdateTexture(nds.menu.drastic.mtext, NULL, nds.menu.drastic.main->pixels, nds.menu.drastic.main->pitch);
+    if (SDL_RenderCopyF(renderer, nds.menu.drastic.mtext, NULL,&dstfrect))
+        printf("Render copy failed\n");
+
+    if (layer == NDS_DRASTIC_MENU_MAIN) {
+	    SDL_Rect ssrect;
+	    SDL_FRect dfrect;
+
+	    ssrect.x = 472;
+	    ssrect.y = 48;//48
+	    ssrect.w = 256;
+	    ssrect.h = 384;
+
+	    dfrect.x = 360.0 / 640.0 * dstfrect.w;//395
+	    dfrect.y = 50.0 / 480.0 * dstfrect.h;
+	    if (res_sel == disp_480x320) {
+		    dfrect.w = 256/4;
+		    dfrect.h = 384/4;
+	    } else {
+		    dfrect.w = 256;
+		    dfrect.h = 384;
+	    }
+	    if (SDL_RenderCopyF(renderer, texture, &ssrect, &dfrect))
+	        printf("Render copy failed\n");
+    }
+
+    memset(&drastic_menu, 0, sizeof(drastic_menu));
+    return 0;
+}
+
+static int nds_render_copy(SDL_Renderer *renderer, SDL_Texture *texture,
+                   const SDL_Rect *srcrect, const SDL_Rect *dstrect)
+{
+	float scale;
+	SDL_FRect dstfrect;
+	struct nds_disp_resize *cur_res = &nds_disp_resize_used[disp_mode];
+	int rect_idx;
+	int ret;
+	int offset_x = 0, offset_y = 0;
+
+	if (disp_mode == DISP_MODE_MENU) {
+		return process_drastic_menu(renderer, texture, &cur_res->menu_dst_rect);
+/*		return SDL_RenderCopy_nds(renderer, texture,
+			&cur_res->menu_src_rect, &cur_res->menu_dst_rect);*/
+	} else if (disp_mode == DISP_MODE_H_SINGLE) {
+		if (nds_tex_is_pointer(texture)) {
+			scale = cur_res->pointer_scale[0];
+			dstfrect.x = (float) dstrect->x * scale + cur_res->tgt_rect[0].x;
+			dstfrect.y = (float) (dstrect->y) * scale + cur_res->tgt_rect[0].y;
+			dstfrect.w = (float) dstrect->w * scale;
+			dstfrect.h = (float) dstrect->h * scale;
+			return SDL_RenderCopyF(renderer, texture, srcrect, &dstfrect);
+		}
+
+		ret = SDL_RenderCopy_nds(renderer, texture, srcrect, &cur_res->tgt_rect[0]);
+		if (unlikely(ret))
+			return ret;
+		if (cur_res->bg_tex)
+			ret = SDL_RenderCopyF(renderer, cur_res->bg_tex, NULL, NULL);
+		return ret;
+	}
+
+	if (nds_tex_is_pointer(texture)) {
+		rect_idx = nds_pointer_in_first_screen(dstrect) ? 0 : 1;
+		scale = cur_res->pointer_scale[rect_idx];
+		if (dstrect->x >= NDS_DRASTIC_H)
+			offset_x = NDS_DRASTIC_H;
+		if (dstrect->y >= NDS_DRASTIC_V)
+			offset_y = NDS_DRASTIC_V;
+		dstfrect.x = (float) (dstrect->x - offset_x) * scale +
+				cur_res->tgt_rect[rect_idx].x;
+		dstfrect.y = (float) (dstrect->y - offset_y) * scale +
+				cur_res->tgt_rect[rect_idx].y;
+		dstfrect.w = (float) dstrect->w * scale;
+		dstfrect.h = (float) dstrect->h * scale;
+		return SDL_RenderCopyF(renderer, texture, srcrect,  &dstfrect);
+	}
+
+    rect_idx = nds_pointer_in_first_screen(dstrect) ? 0 : 1;
+
+    if (rect_idx == 1 && nds_is_overlapping_layout) {
+        SDL_FRect dstfrect;
+
+        dstfrect.x = (float)cur_res->tgt_rect[1].x;
+        dstfrect.y = (float)cur_res->tgt_rect[1].y;
+        dstfrect.w = (float)cur_res->tgt_rect[1].w;
+        dstfrect.h = (float)cur_res->tgt_rect[1].h;
+
+        Uint8 old_alpha;
+        SDL_BlendMode old_blend;
+
+        SDL_GetTextureAlphaMod(texture, &old_alpha);
+        SDL_GetTextureBlendMode(texture, &old_blend);
+
+        /* 半透明小窗，下屏 2DS */
+        SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);
+        SDL_SetTextureAlphaMod(texture, 179);   // 30% 透明，想改就调这个值
+
+        ret = SDL_RenderCopyF(renderer, texture, srcrect, &dstfrect);
+
+        /* 还原状态，避免影响之后别的地方用这个纹理 */
+        SDL_SetTextureAlphaMod(texture, old_alpha);
+        SDL_SetTextureBlendMode(texture, old_blend);
+    } else {
+        /* 其它所有布局 / 所有第一屏，完全走原逻辑 */
+        ret = SDL_RenderCopy_nds(renderer, texture,
+                                 srcrect, &cur_res->tgt_rect[rect_idx]);
+    }
+
+    if (unlikely(ret))
+        return ret;
+
+    /* 如果你不希望 2DS 的第二屏背后再盖 bg_tex，就排除掉它 */
+    if (rect_idx && cur_res->bg_tex && !nds_is_overlapping_layout) {
+        ret = SDL_RenderCopyF(renderer, cur_res->bg_tex, NULL, NULL);
+    }
+
+    return ret;
+
+}
+
 int SDL_RenderCopy(SDL_Renderer *renderer, SDL_Texture *texture,
                    const SDL_Rect *srcrect, const SDL_Rect *dstrect)
 {
     SDL_FRect dstfrect;
     SDL_FRect *pdstfrect = NULL;
+
+	if (disp_mode != DISP_MODE_MAX)
+		return nds_render_copy(renderer, texture,
+			srcrect, dstrect);
+
     if (dstrect) {
         dstfrect.x = (float)dstrect->x;
         dstfrect.y = (float)dstrect->y;
@@ -4405,6 +6561,7 @@ void SDL_DestroyRendererWithoutFreeing(SDL_Renderer *renderer)
 void SDL_DestroyRenderer(SDL_Renderer *renderer)
 {
     CHECK_RENDERER_MAGIC_BUT_NOT_DESTROYED_FLAG(renderer,);
+    nds_drastic_deinit();
 
     /* if we've already destroyed the renderer through SDL_DestroyWindow, we just need
        to free the renderer pointer. This lets apps destroy the window and renderer
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 2f6c631d1..d9241c176 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -33,6 +33,7 @@
 #include "../timer/SDL_timer_c.h"
 
 #include "SDL_syswm.h"
+#include <sys/mman.h>
 
 #include "../render/SDL_sysrender.h"
 
@@ -447,6 +448,233 @@ const char *SDL_GetVideoDriver(int index)
     return NULL;
 }
 
+#define ALIGN_ADDR(addr)    ((void*)((size_t)(addr) & ~(sysconf(_SC_PAGESIZE) - 1)))
+
+void detour_hook(uint32_t old_func, uint32_t new_func)
+{
+    volatile uint8_t *base = (uint8_t *)(intptr_t)old_func;
+
+    mprotect(ALIGN_ADDR(base), sysconf(_SC_PAGESIZE), PROT_READ | PROT_WRITE | PROT_EXEC);
+    base[0] = 0x04;
+    base[1] = 0xf0;
+    base[2] = 0x1f;
+    base[3] = 0xe5;
+    base[4] = new_func >> 0;
+    base[5] = new_func >> 8;
+    base[6] = new_func >> 16;
+    base[7] = new_func >> 24;
+
+    __builtin___clear_cache((void *)ALIGN_ADDR(base), (void *)(ALIGN_ADDR(base) + sysconf(_SC_PAGESIZE)));
+}
+
+extern void sdl_print_string(char *p, uint32_t fg, uint32_t bg, uint32_t x, uint32_t y);
+void sdl_blit_screen_menu(uint16_t *src, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+{
+}
+
+void sdl_update_screen(void)
+{
+}
+
+//#define FUN_PRINT_STRING 0x080a5398
+#define FUN_BLIT_SCREEN_MENU 0x080a62d8
+#define FUN_UPDATE_SCREEN 0x080a83c0
+uint64_t base_addr=0;
+uint64_t base_addr_r=0;
+uint64_t base_addr_rx=0;
+uint64_t base_addr_rw=0;
+#define FUN_PRINT_STRING            (base_addr_rx + 0x00097c30)
+
+void detour_hook_64(uint64_t old_func, uint64_t new_func)
+{
+    int i;
+    
+    volatile uint8_t *base = (uint8_t *)(intptr_t)(/*base_addr_rx + */old_func);
+    //printf(PREFIX"detour_hook++: old_func=0x%lx\n", base);
+    //printf(PREFIX"detour_hook++: new_func=0x%lx\n", new_func);
+    mprotect(ALIGN_ADDR(base), 4096, PROT_READ | PROT_WRITE | PROT_EXEC);
+
+    for(i=0; i<16; i++) {
+    	printf("0x%x,", base[i]);
+    }
+    
+/*
+
+// for armhf
+    base[0] = 0x04;
+    base[1] = 0xf0;
+    base[2] = 0x1f;
+    base[3] = 0xe5;
+    base[4] = new_func >> 0;
+    base[5] = new_func >> 8;
+    base[6] = new_func >> 16;
+    base[7] = new_func >> 24;
+	*/
+	
+	//for aarch64
+	/*
+    400078: 58000049 ldr x9, 400080 <_start+0x8>
+    40007c: d61f0120 br x9
+    400080: 55667788 .word 0x55667788
+    400084: 11223344 .word 0x11223344
+  	*/
+  	/*
+    base[0] = 0x70;
+    base[1] = 0x00;
+    base[2] = 0x00;
+    base[3] = 0x10;
+    base[4] = 0x11;
+    base[5] = 0x02;
+    base[6] = 0x40;
+    base[7] = 0xf9;
+    base[8] = 0x20;
+    base[9] = 0x02;
+    base[10] = 0x1f;
+    base[11] = 0xd6;
+
+ */
+/*
+    memcpy(base, "\xe1\x03\xbe\xa9\x40\x00\x00\x58\x00\x00\x1f\xd6\x00\x00\x00\x00"
+		"\x00\x00\x00\x00\xe1\x03\xc2\xa8", 24);
+    //memcpy(base + 12, new_func, 8);
+    base[12] = new_func >> 0;
+    base[13] = new_func >> 8;
+    base[14] = new_func >> 16;
+    base[15] = new_func >> 24;
+    base[16] = new_func >> 32;
+    base[17] = new_func >> 40;
+    base[18] = new_func >> 48;
+    base[19] = new_func >> 56;  
+    */
+    //base[0] = 0x40; // x0 : 1st parameter of function is corrupted
+    base[0] = 0x51; // x17
+    //base[0] = 0x47;
+    //base[0] = 0x48; // x8
+    //base[0] = 0x49; // x9
+    base[1] = 0x00;
+    base[2] = 0x00;
+    base[3] = 0x58;
+    //base[4] = 0x00; // x0
+    //base[5] = 0x00; // x0
+    
+    base[4] = 0x20; // x17
+    base[5] = 0x02; // x17
+         
+    base[6] = 0x1f;
+    base[7] = 0xd6;
+    base[8] = new_func >> 0;
+    base[9] = new_func >> 8;
+    base[10] = new_func >> 16;
+    base[11] = new_func >> 24;
+    base[12] = new_func >> 32;
+    base[13] = new_func >> 40;
+    base[14] = new_func >> 48;
+    base[15] = new_func >> 56;
+    //printf(PREFIX"detour_hook--\n");
+}
+
+void _pmparser_split_line(
+		char*buf,char*addr1,char*addr2,
+		char*perm,char* offset,char* device,char*inode,
+		char* pathname){
+	//
+	int orig=0;
+	int i=0;
+	//addr1
+	while(buf[i]!='-'){
+		addr1[i-orig]=buf[i];
+		i++;
+	}
+	addr1[i]='\0';
+	i++;
+	//addr2
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		addr2[i-orig]=buf[i];
+		i++;
+	}
+	addr2[i-orig]='\0';
+
+	//perm
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		perm[i-orig]=buf[i];
+		i++;
+	}
+	perm[i-orig]='\0';
+	//offset
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		offset[i-orig]=buf[i];
+		i++;
+	}
+	offset[i-orig]='\0';
+	//dev
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		device[i-orig]=buf[i];
+		i++;
+	}
+	device[i-orig]='\0';
+	//inode
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' '){
+		inode[i-orig]=buf[i];
+		i++;
+	}
+	inode[i-orig]='\0';
+	//pathname
+	pathname[0]='\0';
+	while(buf[i]=='\t' || buf[i]==' ')
+		i++;
+	orig=i;
+	while(buf[i]!='\t' && buf[i]!=' ' && buf[i]!='\n'){
+		pathname[i-orig]=buf[i];
+		i++;
+	}
+	pathname[i-orig]='\0';
+
+}
+
+void detour_init()
+{
+    char addr1[20],addr2[20], perm[8], offset[20], dev[10],inode[30],pathname[4096];
+    FILE* fp;
+
+    fp=fopen("/proc/self/maps", "r");
+    if (fp != NULL) {
+    	char buf[200];
+    	while (fgets(buf, 200, fp) != NULL) {
+    		//printf("%s", buf);
+    		_pmparser_split_line(buf, addr1, addr2, perm, offset, dev, inode, pathname);
+    		if (strcmp(basename(pathname), "drastic") == 0) {
+    			printf("%s, %s, %s, %s, %s, %s, %s\n", addr1, addr2, perm, offset, dev, inode, pathname);
+    			
+    			base_addr = (uint64_t)strtol(addr1, NULL, 16);
+    			if (strcmp(perm, "r-xp") == 0)
+    				base_addr_rx = base_addr; // - 0xd100;
+    			else if (strcmp(perm, "r--p") == 0)
+    				base_addr_r = base_addr;
+    			else if (strcmp(perm, "rw-p") == 0)
+    				base_addr_rw = base_addr - 0x15b000;
+    			printf("base_addr = 0x%lx\n", base_addr);
+    		}
+    	}
+    	fclose(fp);
+    	printf("base_addr_rx = 0x%lx\n", base_addr_rx);
+    	printf("base_addr_r = 0x%lx\n", base_addr_r);
+    	printf("base_addr_rw = 0x%lx\n", base_addr_rw);
+    }
+}
+
 /*
  * Initialize the video and event subsystems -- determine native pixel format
  */
@@ -602,6 +830,11 @@ int SDL_VideoInit(const char *driver_name)
 
     SDL_MousePostInit();
 
+    detour_init();
+    detour_hook_64(FUN_PRINT_STRING, (intptr_t)sdl_print_string);
+    //detour_hook(FUN_BLIT_SCREEN_MENU, (intptr_t)sdl_blit_screen_menu);
+    //detour_hook(FUN_UPDATE_SCREEN, (intptr_t)sdl_update_screen);
+
     /* We're ready to go! */
     return 0;
 
-- 
2.20.1

_SCREEN, (intptr_t)sdl_update_screen);
+
     /* We're ready to go! */
     return 0;
 
-- 
2.20.1

