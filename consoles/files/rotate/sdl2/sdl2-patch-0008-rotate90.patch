diff --git a/src/video/kmsdrm/SDL_kmsdrmmouse.c b/src/video/kmsdrm/SDL_kmsdrmmouse.c
index 3ad5c849f..a04158652 100644
--- a/src/video/kmsdrm/SDL_kmsdrmmouse.c
+++ b/src/video/kmsdrm/SDL_kmsdrmmouse.c
@@ -171,8 +171,18 @@ static int KMSDRM_DumpCursorToBO(SDL_VideoDisplay *display, SDL_Cursor *cursor)
 
     /* Copy from the cursor buffer to a buffer that we can dump to the GBM BO. */
     for (i = 0; i < curdata->h; i++) {
-        src_row = &((uint8_t *)curdata->buffer)[i * curdata->w * 4];
-        SDL_memcpy(ready_buffer + (i * bo_stride), src_row, (size_t)4 * curdata->w);
+        for (j = 0; j < curdata->w; j++) {
+            uint32_t pixel = ((uint32_t *)curdata->buffer)[i * curdata->w + j];
+
+            /* Rotate 90 degrees clockwise:
+             * src(x=j,y=i) -> dst(x=H-1-i, y=j)
+             * dest width becomes curdata->h, dest height becomes curdata->w
+             */
+            int dst_x = (curdata->h - 1) - i;
+            int dst_y = j;
+
+            SDL_memcpy(ready_buffer + dst_y * bo_stride + dst_x * 4, &pixel, 4);
+        }
     }
 
     /* Dump the cursor buffer to our GBM BO. */
@@ -380,7 +390,7 @@ static int KMSDRM_WarpMouseGlobal(int x, int y)
         if (dispdata->cursor_bo) {
             int ret = 0;
 
-            ret = KMSDRM_drmModeMoveCursor(dispdata->cursor_bo_drm_fd, dispdata->crtc->crtc_id, dispdata->mode.hdisplay - curdata->w - x, dispdata->mode.vdisplay - curdata->h - y);
+            ret = KMSDRM_drmModeMoveCursor(dispdata->cursor_bo_drm_fd, dispdata->crtc->crtc_id, dispdata->mode.hdisplay - curdata->h - y, x);
 
 
             if (ret) {
@@ -442,7 +452,7 @@ static void KMSDRM_MoveCursor(SDL_Cursor *cursor)
             return;
         }
 
-        ret = KMSDRM_drmModeMoveCursor(dispdata->cursor_bo_drm_fd, dispdata->crtc->crtc_id, dispdata->mode.hdisplay - curdata->w - mouse->x, dispdata->mode.vdisplay - curdata->h - mouse->y);
+        ret = KMSDRM_drmModeMoveCursor(dispdata->cursor_bo_drm_fd, dispdata->crtc->crtc_id, dispdata->mode.hdisplay - curdata->h - mouse->y, mouse->x);
 
         if (ret) {
             SDL_SetError("drmModeMoveCursor() failed.");
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.c b/src/video/kmsdrm/SDL_kmsdrmvideo.c
index 815c93a52..f70741dfc 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.c
@@ -366,10 +366,10 @@ KMSDRM_InitRotateBuffer(_THIS, int frameWidth, int frameHeight)
     // setup rotation
     src_info.fd = -1;
     src_info.mmuFlag = 1;
-    src_info.rotation = HAL_TRANSFORM_ROT_180;
+    src_info.rotation = HAL_TRANSFORM_ROT_90;
 
     // swap width and height and adjust stride here because our source buffer is 480x854
-    rga_set_rect(&src_info.rect, 0, 0, frameWidth, frameHeight, frameWidth, l_frameHeight, RK_FORMAT_BGRA_8888);
+    rga_set_rect(&src_info.rect, 0, 0, frameHeight, frameWidth, l_frameHeight, frameWidth, RK_FORMAT_BGRA_8888);
 
     dst_info.fd = -1;
     dst_info.mmuFlag = 1;
@@ -943,8 +943,8 @@ static void KMSDRM_AddDisplay(_THIS, drmModeConnector *connector, drmModeRes *re
     modedata->mode_index = mode_index;
 
     display.driverdata = dispdata;
-    display.desktop_mode.w = dispdata->mode.hdisplay;
-    display.desktop_mode.h = dispdata->mode.vdisplay;
+    display.desktop_mode.w = dispdata->mode.vdisplay;
+    display.desktop_mode.h = dispdata->mode.hdisplay;
     display.desktop_mode.refresh_rate = dispdata->mode.vrefresh;
     display.desktop_mode.format = SDL_PIXELFORMAT_ARGB8888;
     display.desktop_mode.driverdata = modedata;
@@ -1226,7 +1226,7 @@ static void KMSDRM_DirtySurfaces(SDL_Window *window)
        or SetWindowFullscreen, send a fake event for now since the actual
        recreation is deferred */
     KMSDRM_GetModeToSet(window, &mode);
-    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, mode.hdisplay, mode.vdisplay);
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, mode.vdisplay, mode.hdisplay);
 }
 
 /* This determines the size of the fb, which comes from the GBM surface
@@ -1261,13 +1261,13 @@ int KMSDRM_CreateSurfaces(_THIS, SDL_Window *window)
        mode that's set in sync with what SDL_video.c thinks is set */
     KMSDRM_GetModeToSet(window, &dispdata->mode);
 
-    display->current_mode.w = dispdata->mode.hdisplay;
-    display->current_mode.h = dispdata->mode.vdisplay;
+    display->current_mode.w = dispdata->mode.vdisplay;
+    display->current_mode.h = dispdata->mode.hdisplay;
     display->current_mode.refresh_rate = dispdata->mode.vrefresh;
     display->current_mode.format = SDL_PIXELFORMAT_ARGB8888;
 
     windata->gs = KMSDRM_gbm_surface_create(viddata->gbm_dev,
-                                            dispdata->mode.hdisplay, dispdata->mode.vdisplay,
+                                            dispdata->mode.vdisplay, dispdata->mode.hdisplay,
                                             surface_fmt, surface_flags);
 
     if (!windata->gs) {
@@ -1291,7 +1291,7 @@ int KMSDRM_CreateSurfaces(_THIS, SDL_Window *window)
     ret = SDL_EGL_MakeCurrent(_this, windata->egl_surface, egl_context);
 
     SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED,
-                        dispdata->mode.hdisplay, dispdata->mode.vdisplay);
+                        dispdata->mode.vdisplay, dispdata->mode.hdisplay);
 
     windata->egl_surface_dirty = SDL_FALSE;
 
@@ -1408,8 +1408,8 @@ void KMSDRM_GetDisplayModes(_THIS, SDL_VideoDisplay *display)
             modedata->mode_index = i;
         }
 
-        mode.w = conn->modes[i].hdisplay;
-        mode.h = conn->modes[i].vdisplay;
+        mode.w = conn->modes[i].vdisplay;
+        mode.h = conn->modes[i].hdisplay;
         mode.refresh_rate = conn->modes[i].vrefresh;
         mode.format = SDL_PIXELFORMAT_ARGB8888;
         mode.driverdata = modedata;
